{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Athena-MVSH","text":"<p>A athena-mvsh \u00e9 uma biblioteca Python projetada para facilitar a execu\u00e7\u00e3o de consultas no AWS Athena com suporte ao uso de pyarrow e DuckDB para resultados e execu\u00e7\u00e3o de consultas. A biblioteca oferece uma interface intuitiva, integrando com o Athena e outros formatos de dados, como Parquet, CSV, e Arrow, permitindo exporta\u00e7\u00f5es e transforma\u00e7\u00f5es de dados eficientes.</p> <p>Al\u00e9m disso, athena-mvsh implementa partes da DB API 2.0 (PEP 249), garantindo que a intera\u00e7\u00e3o com o Athena seja simples e padronizada, seguindo as boas pr\u00e1ticas de acesso a bancos de dados em Python.</p>"},{"location":"#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Execu\u00e7\u00e3o de consultas no Athena: Execute consultas SQL no AWS Athena e manipule os resultados com facilidade.</li> <li>Suporte a formatos de dados: Converta os resultados para Parquet, CSV, Arrow, e Pandas DataFrames.</li> <li>Conformidade com DB API 2.0 (PEP 249): A biblioteca segue v\u00e1rias conven\u00e7\u00f5es da DB API 2.0, como o uso de cursores, gerenciamento de exce\u00e7\u00f5es e execu\u00e7\u00e3o de consultas.</li> <li>Gerenciamento de Contexto: Utilize a biblioteca com a sintaxe <code>with</code> para garantir a limpeza de recursos ao final de uma opera\u00e7\u00e3o.</li> </ul>"},{"location":"#conformidade-com-db-api-20-pep-249","title":"Conformidade com DB API 2.0 (PEP 249)","text":"<p>A athena-mvsh foi projetada para implementar a interface padr\u00e3o de acesso a bancos de dados em Python, seguindo as diretrizes da DB API 2.0 (PEP 249). Abaixo est\u00e3o alguns dos componentes implementados:</p>"},{"location":"#1-cursor","title":"1. Cursor","text":"<p>O Cursor \u00e9 respons\u00e1vel por interagir com o banco de dados, executar consultas e recuperar resultados. A biblioteca <code>athena-mvsh</code> implementa a classe <code>Athena</code>, que se comporta como um cursor:</p> <ul> <li>Cria\u00e7\u00e3o do Cursor: O cursor \u00e9 criado a partir de um objeto <code>DBAthena</code> (que pode ser um <code>CursorPython</code>, <code>CursorParquet</code>, ou <code>CursorParquetDuckdb</code>), e gerencia a execu\u00e7\u00e3o de consultas no Athena.</li> <li>M\u00e9todos principais:</li> <li><code>execute(query, parameters=None)</code>: Executa uma consulta SQL.</li> <li><code>fetchone()</code>: Recupera a pr\u00f3xima linha de um resultado.</li> <li><code>fetchall()</code>: Recupera todas as linhas de um resultado.</li> <li><code>fetchmany(size)</code>: Recupera um n\u00famero especificado de linhas.</li> </ul>"},{"location":"#2-execucao-de-consultas","title":"2. Execu\u00e7\u00e3o de Consultas","text":"<ul> <li><code>execute(query, parameters=None)</code>: Executa uma consulta SQL. Caso par\u00e2metros sejam fornecidos, a biblioteca os passa de forma segura.</li> <li>Consultas DML e DDL: Suporte a consultas de manipula\u00e7\u00e3o de dados e defini\u00e7\u00e3o de dados.</li> </ul>"},{"location":"#3-propriedades-e-metodos-do-cursor","title":"3. Propriedades e M\u00e9todos do Cursor","text":"<p>A <code>athena-mvsh</code> implementa m\u00e9todos e propriedades como a <code>description</code> (descri\u00e7\u00e3o das colunas do resultado) e <code>rowcount</code> (n\u00famero de linhas afetadas pela consulta), conforme esperado pela DB API 2.0:</p> <ul> <li> <p><code>description</code>: Retorna uma lista com informa\u00e7\u00f5es sobre as colunas da consulta.   <pre><code>print(cursor.description)\n</code></pre></p> </li> <li> <p><code>rowcount</code>: Retorna o n\u00famero de linhas afetadas pela consulta.   <pre><code>print(cursor.rowcount)\n</code></pre></p> </li> </ul>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<pre><code>pip install athena-mvsh\n</code></pre>"},{"location":"#credenciais","title":"Credenciais","text":"<p>Para se conectar \u00e9 preciso informar o <code>aws_access_key_id</code>, <code>aws_secret_access_key</code> o local de saida das consultas <code>s3_staging_dir</code>  e a regiao do bucket <code>region_name</code>. Se voc\u00ea usar o arquivo de perfil padr\u00e3o, n\u00e3o ser\u00e1 necess\u00e1rio informar as credenciais.</p> <pre><code>from athena_mvsh import (\n    Athena,\n    CursorPython\n)\n\ncursor = CursorPython(\n    s3_staging_dir='s3://caminho-saida-consulta/',\n    aws_access_key_id='KEY_ID',\n    aws_secret_access_key='SECRET_KEY',\n    region_name='us-east-1'\n)\n</code></pre>"},{"location":"#iteracao-do-cursor","title":"Itera\u00e7\u00e3o do cursor","text":"<p>O cursor fornecido por esta biblioteca implementa o protocolo de iterator do Python, permitindo que voc\u00ea itere sobre os resultados da consulta linha por linha. Isso \u00e9 \u00fatil para processar grandes conjuntos de dados sem precisar carreg\u00e1-los completamente na mem\u00f3ria.</p> <pre><code>cursor = CursorPython(\n  s3_staging_dir='s3://caminho-saida-consulta/'\n)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT * FROM sales_data\")\n    for row in athena:\n        print(row)\n</code></pre>"},{"location":"#exemplo-de-uso","title":"Exemplo de Uso","text":"<p>A seguir, um exemplo de como utilizar a biblioteca athena-mvsh para executar uma consulta e manipular os resultados:</p>"},{"location":"#1-uso-basico","title":"1. Uso B\u00e1sico","text":"<pre><code>from athena_mvsh import Athena, CursorPython\n\ncursor = CursorPython(\n  s3_staging_dir='s3:/caminho-saida-consulta/'\n)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT * FROM sales_data\")\n    print(athena.fetchall())\n    print(athena.description)\n    print(athena.rowcount)\n</code></pre>"},{"location":"#2-reutilizacao-de-consultas","title":"2. Reutiliza\u00e7\u00e3o de consultas","text":"<p>O par\u00e2metro <code>result_reuse_enable</code> \u00e9 uma funcionalidade que habilita ou desabilita a reutiliza\u00e7\u00e3o de resultados de consultas previamente executadas no Amazon Athena. Essa abordagem reduz custos e melhora o desempenho ao aproveitar resultados armazenados em cache, desde que os dados subjacentes n\u00e3o tenham sido alterados.</p> <pre><code>from athena_mvsh import Athena, CursorPython\n\ncursor = CursorPython(\n  s3_staging_dir='s3://caminho-saida-consulta/',\n  result_reuse_enable=True\n)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT * FROM sales_data\")\n    print(athena.fetchone())\n</code></pre>"},{"location":"#duckdb-consulta-e-transformacao","title":"DuckDB consulta e transforma\u00e7\u00e3o","text":"<p>A biblioteca suporta a execu\u00e7\u00e3o de consultas no Amazon Athena utilizando o recurso UNLOAD para exportar os resultados diretamente em formato Parquet no Amazon S3. Em seguida, o DuckDB \u00e9 utilizado para carregar e processar esses dados localmente, aproveitando as vantagens do formato Parquet para consultas anal\u00edticas r\u00e1pidas e eficientes.</p> <p>\u00c9 poss\u00edvel criar tabelas externas e do tipo Iceberg diretamente a partir de DataFrames do pandas, Table Arrow ou arquivos Parquet. Essa funcionalidade permite que dados estruturados sejam facilmente integrados a ambientes anal\u00edticos, facilitando o uso em consultas SQL e outras opera\u00e7\u00f5es anal\u00edticas</p>"},{"location":"#metodos-disponiveis","title":"M\u00e9todos dispon\u00edveis","text":"<ul> <li>to_arrow: Converte os resultados para um formato Arrow.</li> <li>to_pandas: Converte os resultados para um DataFrame Pandas.</li> <li>to_parquet: Converte os resultados para o formato Parquet.</li> <li>to_csv: Converte os resultados para um arquivo CSV.</li> <li>to_create_table_db: Cria uma tabela no DuckDB usando os resultados.</li> <li>to_partition_create_table_db: Cria uma tabela no DuckDB inserindo os dados de forma incremental.</li> <li>to_insert_table_db: Insere dados em uma tabela do DuckDB.</li> <li>write_dataframe: Escreve um DataFrame em uma tabela externa no Athena.</li> <li>write_arrow: Escreve um Table Arrow em uma tabela externa no Athena.</li> <li>write_parquet: Escreve dados a partir de um ou mais arquivos <code>.parquet</code> em uma tabela externa no Athena.</li> <li>write_table_iceberg: Cria uma tabela do tipo <code>Iceberg</code> no Athena</li> <li>merge_table_iceberg: Realiza uma opera\u00e7\u00e3o de merge em uma tabela <code>Iceberg</code>.</li> </ul>"},{"location":"#1-criando-tabela-no-duckdb-a-partir-de-uma-consulta","title":"1. Criando tabela no Duckdb a partir de uma consulta","text":"<pre><code>from athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(\n    s3_staging_dir='s3://caminho-saida-consulta/'\n)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT * FROM sales_data\")\n    athena.to_create_table_db('sales_table', database='db.duckdb')\n</code></pre>"},{"location":"#2-criando-tabela-externa-no-athena-a-partir-de-um-dataframe-do-pandas","title":"2. Criando tabela externa no Athena a partir de um DataFrame do pandas","text":"<pre><code>import pandas as pd\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(\n    s3_staging_dir='s3://caminho-saida-consulta/'\n)\n\ndf = pd.read_excel('caminho_plan.xlsx')\n\nwith Athena(cursor=cursor) as athena:\n    athena.write_dataframe(\n        df,\n        schema='schema-tabela',\n        table_name='nome_tabela',\n        location=f's3://caminho-saida-tabela/tabela/nome_tabela/',\n    )\n</code></pre>"},{"location":"#3-criando-tabela-externa-no-athena-a-partir-de-arquivos-parquet","title":"3. Criando tabela externa no Athena a partir de arquivos Parquet","text":"<pre><code>import pandas as pd\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(\n    s3_staging_dir='s3://caminho-saida-consulta/'\n)\n\nwith Athena(cursor=cursor) as athena:\n    athena.write_parquet(\n        'arquivo_parquet.parquet',\n        schema='schema-tabela',\n        table_name='nome_tabela',\n        location=f's3://caminho-saida-tabela/tabela/nome_tabela/',\n    )\n</code></pre>"},{"location":"referencia/","title":"Referencia","text":"<p>A classe Athena estende a funcionalidade de <code>CursorIterator</code> para executar consultas SQL no Athena, gerenciar os resultados e fornecer m\u00e9todos para exportar os dados para diversos formatos (CSV, Parquet, Iceberg, etc.).</p> <p>Ela permite a execu\u00e7\u00e3o de consultas SQL, a obten\u00e7\u00e3o dos resultados de forma iterativa e a convers\u00e3o desses resultados para estruturas de dados como Pandas DataFrame, Parquet ou Arrow. A classe tamb\u00e9m oferece m\u00e9todos para escrever dados de volta ao banco de dados ou armazen\u00e1-los em formatos como Parquet e Iceberg, com suporte para opera\u00e7\u00f5es de particionamento e compress\u00e3o.</p> O tipo de cursor utilizado pode ser um dos seguintes <ul> <li>CursorPython: Para opera\u00e7\u00f5es com Python.</li> <li>CursorParquet: Para opera\u00e7\u00f5es com dados Parquet em integra\u00e7\u00e3o com Pyarrow.</li> <li>CursorParquetDuckdb: Para opera\u00e7\u00f5es com dados Parquet em integra\u00e7\u00e3o com DuckDB.</li> </ul> M\u00e9todos <ul> <li>execute: Executa uma consulta SQL, com par\u00e2metros opcionais.</li> <li>fetchone: Retorna a pr\u00f3xima linha do resultado.</li> <li>fetchall: Retorna todas as linhas do resultado.</li> <li>fetchmany: Retorna um n\u00famero especificado de linhas.</li> <li>to_arrow: Converte os resultados para um formato Arrow.</li> <li>to_parquet: Converte os resultados para o formato Parquet.</li> <li>to_csv: Converte os resultados para um arquivo CSV.</li> <li>to_create_table_db: Cria uma tabela no banco de dados usando os resultados.</li> <li>to_partition_create_table_db: Cria uma tabela particionada no banco de dados.</li> <li>to_insert_table_db: Insere dados em uma tabela do banco de dados.</li> <li>write_dataframe: Escreve um DataFrame em uma tabela no banco de dados.</li> <li>write_arrow: Escreve um Table Arrow em uma tabela no banco de dados.</li> <li>write_parquet: Escreve dados em formato Parquet no banco de dados.</li> <li>write_table_iceberg: Escreve dados em formato Iceberg no banco de dados.</li> <li>merge_table_iceberg: Realiza uma opera\u00e7\u00e3o de merge em uma tabela Iceberg.</li> <li>to_pandas: Converte os resultados para um DataFrame Pandas.</li> <li>close: Libera os recursos utilizados pela consulta.</li> <li>enter / exit: Suporte para contexto (gerenciamento de recursos).</li> </ul> Exce\u00e7\u00f5es <ul> <li>ProgrammingError: Lan\u00e7ada quando um m\u00e9todo n\u00e3o \u00e9 implementado para o tipo de cursor atual.</li> </ul> Exemplo de uso <p>Supondo que o cursor seja uma inst\u00e2ncia v\u00e1lida de um dos tipos: CursorPython, CursorParquet ou CursorParquetDuckdb</p> <pre><code>from athena_mvsh import CursorPython, CursorParquet, CursorParquetDuckdb\n\ncursor = CursorPython(...)  # ou CursorParquet(...) ou CursorParquetDuckdb(...)\n</code></pre> <p>Criando uma inst\u00e2ncia da classe Athena <pre><code>with Athena(cursor) as athena:\n    # Executando uma consulta SQL\n    athena.execute(\"SELECT * FROM sales_data WHERE region = 'US'\")\n\n    # Obtendo os resultados\n    results = athena.fetchall()\n    for row in results:\n        print(row)\n\n    # Convertendo os resultados para um DataFrame Pandas\n    df = athena.to_pandas()\n    print(df.head())\n\n    # Exportando os resultados para um arquivo CSV\n    athena.to_csv(\"sales_data_us.csv\", delimiter=\";\", include_header=True)\n\n    # Escrevendo dados em uma tabela no banco de dados\n    athena.write_parquet(\n        file=\"sales_data.parquet\",\n        table_name=\"sales_table\",\n        schema=\"public\"\n    )\n</code></pre></p>"},{"location":"referencia/#athena_mvsh.connection.Athena","title":"<code>Athena</code>","text":"<p>               Bases: <code>CursorIterator</code></p> <p>Classe respons\u00e1vel por executar consultas SQL no AWS Athena ou em cursores alternativos, como CursorParquetDuckdb, CursorPython ou CursorParquet. A classe suporta gerenciamento autom\u00e1tico de recursos com o uso de um gerenciador de contexto.</p> <p>Attributes:</p> Name Type Description <code>cursor</code> <code>CursorParquetDuckdb | CursorPython | CursorParquet</code> <p>Inst\u00e2ncia do cursor utilizado para executar consultas.</p> <code>row_cursor</code> <p>Armazena o resultado da execu\u00e7\u00e3o da query.</p>"},{"location":"referencia/#athena_mvsh.connection.Athena.description","title":"<code>description</code>  <code>property</code>","text":"<p>Retorna os metadados da consulta executada.</p> <p>Esta propriedade retorna uma lista de tuplas que representam as colunas da consulta executada. Cada tupla cont\u00e9m as seguintes informa\u00e7\u00f5es:     - Nome da coluna     - Tipo da coluna     - (Valor n\u00e3o utilizado, sempre <code>None</code>)     - (Valor n\u00e3o utilizado, sempre <code>None</code>)     - Precis\u00e3o da coluna     - Escala da coluna     - Se a coluna pode ser nula (<code>Nullable</code>)</p> Retorno <p>list[tuple] | None: Uma lista de tuplas contendo os metadados de cada coluna ou <code>None</code> se os metadados n\u00e3o estiverem dispon\u00edveis.</p> Exemplo <pre><code>cursor = CursorPython(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    print(athena.description)\n[('id', 'INTEGER', None, None, 10, 0, True), ('name', 'STRING', None, None, None, None, True)]\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.rowcount","title":"<code>rowcount</code>  <code>property</code>","text":"<p>Retorna o n\u00famero total de registros afetados pela execu\u00e7\u00e3o da consulta.</p> <p>Este m\u00e9todo recupera o n\u00famero de registros afetados pela \u00faltima execu\u00e7\u00e3o de consulta, como determinado pelo cursor utilizado. O valor \u00e9 fornecido pela implementa\u00e7\u00e3o do cursor, seguindo as especifica\u00e7\u00f5es da DB API Python.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>O n\u00famero total de registros afetados pela \u00faltima execu\u00e7\u00e3o de consulta.</p> Notes <ul> <li>O valor retornado pode variar dependendo do tipo de consulta executada (como <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>).</li> <li>O m\u00e9todo <code>rowcount</code> depende da implementa\u00e7\u00e3o do cursor espec\u00edfico. Por exemplo, cursors como <code>CursorPython</code>, <code>CursorParquetDuckdb</code> ou outros tipos podem ter diferentes formas de calcular os registros afetados.</li> <li>Se a consulta n\u00e3o afetar nenhum registro, o valor retornado ser\u00e1 <code>-1</code>.</li> </ul> Exemplo <pre><code>from athena_mvsh import Athena, CursorPython\n\ncursor = CursorPython(...)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"UPDATE tabela SET coluna = 'valor' WHERE condicao = 'verdadeira'\")\n    print(f\"Registros afetados: {athena_cursor.rowcount}\")\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.__init__","title":"<code>__init__(cursor)</code>","text":"<p>Inicializa a classe Athena com um cursor, permitindo a execu\u00e7\u00e3o de consultas SQL.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>CursorParquetDuckdb | CursorPython | CursorParquet</code> <p>Inst\u00e2ncia do cursor que define o backend para execu\u00e7\u00e3o das queries.</p> required"},{"location":"referencia/#athena_mvsh.connection.Athena.execute","title":"<code>execute(query, parameters=None, *, result_reuse_enable=False)</code>","text":"<p>Executa uma consulta SQL no backend configurado pelo cursor.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>A string da consulta SQL a ser executada.</p> required <code>parameters</code> <code>tuple | dict</code> <p>Par\u00e2metros para a consulta. - Se for uma tupla, \u00e9 interpretada como argumentos posicionais. - Se for um dicion\u00e1rio, \u00e9 interpretado como argumentos nomeados. - Padr\u00e3o \u00e9 None.</p> <code>None</code> <code>result_reuse_enable</code> <code>bool</code> <p>Habilita a reutiliza\u00e7\u00e3o de resultados da consulta armazenados em cache (se suportado pelo cursor). Padr\u00e3o \u00e9 False.</p> <code>False</code> Retorno <p>self: A inst\u00e2ncia atual da classe Athena, permitindo chamadas encadeadas.</p> Notes <ul> <li>A classe \u00e9 compat\u00edvel com os cursores:</li> <li><code>CursorParquetDuckdb</code></li> <li><code>CursorPython</code></li> <li><code>CursorParquet</code></li> <li> <p>Cada cursor deve ser inicializado com os seguintes par\u00e2metros obrigat\u00f3rios:</p> <ul> <li><code>s3_staging_dir</code> (str): Diret\u00f3rio no Amazon S3 usado como \u00e1rea de staging.</li> <li><code>schema_name</code> (str, optional): Nome do schema do banco de dados.</li> <li><code>catalog_name</code> (str, optional): Nome do cat\u00e1logo no Athena.</li> <li><code>poll_interval</code> (float, optional): Intervalo em segundos entre verifica\u00e7\u00f5es de consulta. Padr\u00e3o: 1.0.</li> <li><code>result_reuse_enable</code> (bool, optional): Habilita reutiliza\u00e7\u00e3o de resultados.</li> </ul> </li> <li> <p>Caso as configura\u00e7\u00f5es do AWS CLI n\u00e3o estejam dispon\u00edveis, os par\u00e2metros opcionais   para autentica\u00e7\u00e3o podem ser passados como kwargs ao instanciar os cursores:</p> <ul> <li><code>region_name</code> (str): Regi\u00e3o da AWS.</li> <li><code>aws_access_key_id</code> (str): Chave de acesso da AWS.</li> <li><code>aws_secret_access_key</code> (str): Chave secreta de acesso da AWS.</li> </ul> </li> <li> <p>Se a consulta for um comando DDL (ex.: CREATE, ALTER, DROP), o m\u00e9todo retorna o resultado   de <code>fetchone()</code> imediatamente.</p> </li> </ul> Exemplo <pre><code>from athena_mvsh import Athena, CursorParquetDuckdb\n</code></pre> <p>Inicializando CursorParquetDuckdb com credenciais AWS <pre><code>cursor = CursorParquetDuckdb(\n    s3_staging_dir=\"s3://my-bucket/staging/\",\n    schema_name=\"default\",\n    catalog_name=\"awsdatacatalog\",\n    region_name=\"us-west-2\",\n    aws_access_key_id=\"my-access-key\",\n    aws_secret_access_key=\"my-secret-key\"\n)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT * FROM example_table\").fetchall()\n</code></pre></p> <p>Inicializando CursorPython sem credenciais adicionais (usa AWS CLI configurado) <pre><code>cursor = CursorPython(\n    s3_staging_dir=\"s3://my-bucket/staging/\"\n )\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT COUNT(*) FROM parquet_data\")\n</code></pre></p> <p>Inicializando CursorParquet com credenciais <pre><code>cursor = CursorParquet(\n    s3_staging_dir=\"s3://my-bucket/staging/\",\n    schema_name=\"analytics\",\n    region_name=\"us-west-1\",\n    aws_access_key_id=\"my-access-key\",\n    aws_secret_access_key=\"my-secret-key\"\n)\n\nwith Athena(cursor) as athena:\n    result = athena.execute(\"SELECT * FROM parquet_table\").fetchone()\nprint(result)\n(1000,)\n</code></pre></p>"},{"location":"referencia/#athena_mvsh.connection.Athena.fetchall","title":"<code>fetchall()</code>","text":"<p>Retorna todas as linhas do cursor como uma lista.</p> <p>Este m\u00e9todo converte todas as linhas dispon\u00edveis no cursor em uma lista de tuplas, onde cada tupla representa uma linha do resultado da consulta executada.</p> Retorno <p>list: Uma lista de tuplas representando todas as linhas retornadas pela consulta.</p> Exemplo <pre><code>cursor = CursorPython(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    rows = athena.fetchall()\n    print(rows)  # Exemplo: [(1, 'Alice'), (2, 'Bob'), (3, 'Charlie')]\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.fetchmany","title":"<code>fetchmany(size=1)</code>","text":"<p>Retorna um n\u00famero especificado de linhas do cursor.</p> <p>Este m\u00e9todo retorna at\u00e9 <code>size</code> linhas do cursor, como uma lista de tuplas. Se o n\u00famero de linhas dispon\u00edveis for menor que o valor de <code>size</code>, ele retorna o n\u00famero de linhas restantes. O valor padr\u00e3o de <code>size</code> \u00e9 1.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>(int, opcional)</code> <p>O n\u00famero de linhas a serem retornadas. O valor padr\u00e3o \u00e9 1.</p> <code>1</code> Retorno <p>list: Uma lista de tuplas representando as linhas retornadas pelo cursor.</p> Exemplo <pre><code>cursor = CursorPython(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    rows = athena.fetchmany(2)\n    print(rows)  # Exemplo: [(1, 'Alice'), (2, 'Bob')]\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.fetchone","title":"<code>fetchone()</code>","text":"<p>Retorna a pr\u00f3xima linha do cursor.</p> <p>Este m\u00e9todo tenta obter a pr\u00f3xima linha do cursor. Se houver uma linha dispon\u00edvel, ela \u00e9 retornada. Caso contr\u00e1rio, retorna <code>None</code> quando o cursor atingir o final dos resultados.</p> Retorno <p>tuple | None: Retorna a pr\u00f3xima linha como uma tupla ou <code>None</code> se n\u00e3o houver mais linhas.</p> Exemplo <pre><code>cursor = CursorPython(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    print(athena.fetchone())  # Exemplo de uma linha retornada: (1, 'Alice')\n    print(athena.fetchone())  # Exemplo de uma linha retornada: (2, 'Bob')\n    print(athena.fetchone())  # Exemplo de retorno `None`, se n\u00e3o houver mais dados\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.merge_table_iceberg","title":"<code>merge_table_iceberg(target_table, source_data, schema, predicate, delete_condition=None, update_condition=None, insert_condition=None, alias=('t', 's'), sync_schema=False, location=None, catalog_name='awsdatacatalog')</code>","text":"<p>Executa um merge (UPSERT) em uma tabela Iceberg no Athena, utilizando uma tabela tempor\u00e1ria criada no Athena.</p> <p>Este m\u00e9todo usa o DuckDB para criar uma tabela tempor\u00e1ria no Athena com os dados fornecidos e, em seguida, executa um merge (UPSERT) entre a tabela de destino e os dados da tabela tempor\u00e1ria. A opera\u00e7\u00e3o permite atualizar ou inserir registros na tabela de destino com base em uma condi\u00e7\u00e3o de jun\u00e7\u00e3o (predicate). Pode-se utilizar um DataFrame pandas, Table Arrow ou arquivos Parquet como dados de origem.</p> <p>Parameters:</p> Name Type Description Default <code>target_table</code> <code>str</code> <p>O nome da tabela de destino do tipo Iceberg no Athena, onde os dados ser\u00e3o mesclados.</p> required <code>source_data</code> <code>DataFrame | list[str | Path] | str | Path | Table</code> <p>Dados de origem a serem mesclados com a tabela de destino. Pode ser um DataFrame pandas, Table Arrow ou um ou mais arquivos Parquet (caminhos em formato string ou Path).</p> required <code>schema</code> <code>str</code> <p>O esquema onde a tabela Iceberg ser\u00e1 manipulada no Athena.</p> required <code>predicate</code> <code>str</code> <p>A condi\u00e7\u00e3o de jun\u00e7\u00e3o (predicate) que define a l\u00f3gica de correspond\u00eancia entre os dados de origem e os dados da tabela de destino para o merge (atualiza\u00e7\u00e3o ou inser\u00e7\u00e3o).</p> required <code>delete_condition</code> <code>(str, opcional)</code> <p>Condi\u00e7\u00e3o para excluir registros da tabela de destino. Se <code>None</code>, a cl\u00e1usula <code>DELETE</code> n\u00e3o ser\u00e1 aplicada.</p> <code>None</code> <code>update_condition</code> <code>(str, opcional)</code> <p>Condi\u00e7\u00e3o para atualizar registros existentes na tabela de destino. Se <code>None</code>, todos os registros correspondentes ser\u00e3o atualizados..</p> <code>None</code> <code>insert_condition</code> <code>(str, opcional)</code> <p>Condi\u00e7\u00e3o para inserir novos registros na tabela de destino. Se <code>None</code>, todos os registros correspondentes ser\u00e3o inseridos.</p> <code>None</code> <code>alias</code> <code>tuple</code> <p>Alias para as tabelas de origem e destino no merge. O valor padr\u00e3o \u00e9 <code>('t', 's')</code>, onde <code>'t'</code> \u00e9 o alias da tabela de destino e <code>'s'</code> \u00e9 o alias da tabela de origem.</p> <code>('t', 's')</code> <code>sync_schema</code> <code>bool</code> <p>Indica se o esquema da tabela de destino deve ser sincronizado com os dados de origem. O valor padr\u00e3o \u00e9 <code>False</code>.</p> <code>False</code> <code>location</code> <code>str</code> <p>O local no S3 onde os dados ser\u00e3o armazenados, se aplic\u00e1vel.</p> <code>None</code> <code>catalog_name</code> <code>str</code> <p>O nome do cat\u00e1logo de dados a ser utilizado. O valor padr\u00e3o \u00e9 <code>'awsdatacatalog'</code>.</p> <code>'awsdatacatalog'</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se a fun\u00e7\u00e3o for chamada com um cursor incompat\u00edvel.</p> Detalhes <ul> <li>O m\u00e9todo cria uma tabela tempor\u00e1ria no Athena com os dados fornecidos (DataFrame pandas, Table Arrow ou arquivos Parquet) e executa um merge (UPSERT) entre a tabela de destino (Iceberg) e a tabela tempor\u00e1ria.</li> <li>O <code>predicate</code> define a condi\u00e7\u00e3o de jun\u00e7\u00e3o para o merge, permitindo atualizar ou inserir registros na tabela de destino.</li> <li>O par\u00e2metro <code>alias</code> \u00e9 utilizado para dar nomes alias \u00e0s tabelas de origem e destino durante a execu\u00e7\u00e3o do SQL gerado.</li> <li>O par\u00e2metro <code>catalog_name</code> permite configurar o cat\u00e1logo de dados, sendo <code>'awsdatacatalog'</code> o valor padr\u00e3o.</li> </ul> Exemplo <pre><code>import pandas as pd\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(...)\n\n# Exemplo de DataFrame\ndf = pd.DataFrame({\n    \"id\": [1, 2, 3],\n    \"nome\": [\"A\", \"B\", \"C\"]\n})\n\n# Realiza um merge (UPSERT) na tabela Iceberg no Athena, utilizando uma tabela tempor\u00e1ria\nwith Athena(cursor) as athena:\n    athena.merge_table_iceberg(\n        target_table=\"tabela_destino\",\n        source_data=df,\n        schema=\"meu_esquema\",\n        predicate=\"t.id = s.id\",\n        alias=(\"t\", \"s\"),\n        location=\"s3://meu-bucket/dados/\",\n        catalog_name=\"meu_catalogo\"\n    )\n</code></pre> Notas <ul> <li>Certifique-se de que o cursor utilizado seja inst\u00e2ncia de <code>CursorParquetDuckdb</code>.</li> <li>O <code>predicate</code> deve ser uma express\u00e3o l\u00f3gica v\u00e1lida para a jun\u00e7\u00e3o dos dados da origem com os dados da tabela de destino.</li> <li>A opera\u00e7\u00e3o de merge cria uma tabela tempor\u00e1ria no Athena para facilitar a execu\u00e7\u00e3o do merge. O uso de uma tabela tempor\u00e1ria pode otimizar o processo, especialmente quando os dados de origem s\u00e3o grandes.</li> </ul>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_arrow","title":"<code>to_arrow()</code>","text":"<p>Converte os resultados da consulta para um <code>pa.Table</code> (PyArrow Table).</p> <p>Este m\u00e9todo converte os dados retornados pela consulta executada em um objeto <code>pa.Table</code> (tabela do PyArrow). A convers\u00e3o s\u00f3 \u00e9 realizada se o cursor utilizado for uma inst\u00e2ncia de <code>CursorParquet</code> ou <code>CursorParquetDuckdb</code>. Caso contr\u00e1rio, uma exce\u00e7\u00e3o <code>ProgrammingError</code> ser\u00e1 levantada.</p> Exce\u00e7\u00f5es <p>ProgrammingError: Se o cursor n\u00e3o for uma inst\u00e2ncia de <code>CursorParquet</code> ou <code>CursorParquetDuckdb</code>.</p> Retorno <p>pa.Table: Um objeto <code>pa.Table</code> contendo os resultados da consulta.</p> Exemplo <pre><code>cursor = CursorParquet(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    table = athena.to_arrow()\n    print(table)  # Exemplo de sa\u00edda: &lt;pyarrow.table&gt;\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_create_table_db","title":"<code>to_create_table_db(table_name, *, database='db.duckdb')</code>","text":"<p>Cria uma tabela no banco de dados DuckDB com base nos resultados da consulta executada.</p> <p>Este m\u00e9todo cria uma tabela no banco de dados DuckDB especificado usando os dados retornados pela consulta executada. A tabela ser\u00e1 criada com o nome fornecido como <code>table_name</code>.</p> <p>O m\u00e9todo s\u00f3 pode ser utilizado com o cursor do tipo <code>CursorParquetDuckdb</code>. O nome do banco de dados pode ser especificado como um argumento, e se n\u00e3o fornecido, o banco de dados padr\u00e3o ser\u00e1 <code>'db.duckdb'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>O nome da tabela a ser criada no banco de dados.</p> required <code>database</code> <code>(str, opcional)</code> <p>O nome do banco de dados onde a tabela ser\u00e1 criada. O valor padr\u00e3o \u00e9 <code>'db.duckdb'</code>.</p> <code>'db.duckdb'</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se o cursor n\u00e3o for uma inst\u00e2ncia de <code>CursorParquetDuckdb</code>.</p> Retorno <p>None: Este m\u00e9todo n\u00e3o retorna valor, mas cria a tabela no banco de dados.</p> Exemplo <pre><code>cursor = CursorParquetDuckdb(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    athena.to_create_table_db('users_table')\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_csv","title":"<code>to_csv(output_file, delimiter=';', include_header=True)</code>","text":"<p>Converte os resultados da consulta para um arquivo CSV.</p> <p>Este m\u00e9todo converte os dados retornados pela consulta executada e os salva em um arquivo CSV. A convers\u00e3o \u00e9 realizada apenas se o cursor utilizado for do tipo <code>CursorParquet</code> ou <code>CursorParquetDuckdb</code>. Dependendo do tipo do cursor, o m\u00e9todo chama a fun\u00e7\u00e3o <code>to_csv</code> correspondente.</p> <ul> <li> <p>Se o cursor for uma inst\u00e2ncia de <code>CursorParquetDuckdb</code>, o m\u00e9todo chamar\u00e1 diretamente o m\u00e9todo <code>to_csv</code> do cursor, passando os par\u00e2metros apropriados para ele.</p> </li> <li> <p>Para o cursor <code>CursorParquet</code>, os dados s\u00e3o primeiro convertidos para um <code>pa.Table</code> e ent\u00e3o salvos como CSV, com op\u00e7\u00f5es de escrita personaliz\u00e1veis.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str</code> <p>O caminho do arquivo CSV de sa\u00edda.</p> required <code>delimiter</code> <code>(str, opcional)</code> <p>O delimitador a ser usado no arquivo CSV. O valor padr\u00e3o \u00e9 <code>';'</code>.</p> <code>';'</code> <code>include_header</code> <code>(bool, opcional)</code> <p>Indica se o cabe\u00e7alho deve ser inclu\u00eddo no CSV. O valor padr\u00e3o \u00e9 <code>True</code>.</p> <code>True</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se o cursor n\u00e3o for uma inst\u00e2ncia de <code>CursorParquet</code> ou <code>CursorParquetDuckdb</code>.</p> Retorno <p>None: Este m\u00e9todo n\u00e3o retorna valor, mas realiza a convers\u00e3o para o formato CSV.</p> Exemplo <pre><code>cursor = CursorParquet(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    athena.to_csv('/path/to/file.csv')\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_insert_table_db","title":"<code>to_insert_table_db(table_name, *, database='db.duckdb')</code>","text":"<p>Insere os resultados de uma consulta executada no Amazon Athena em uma tabela no DuckDB.</p> <p>Esta fun\u00e7\u00e3o utiliza o cursor espec\u00edfico da biblioteca, <code>CursorParquetDuckdb</code>, para transferir os dados resultantes de uma consulta executada no Amazon Athena para uma tabela no banco de dados DuckDB. Caso o cursor utilizado n\u00e3o seja compat\u00edvel, um erro ser\u00e1 lan\u00e7ado.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>O nome da tabela de destino no DuckDB onde os dados ser\u00e3o inseridos.</p> required <code>database</code> <code>str</code> <p>O caminho ou nome do banco de dados DuckDB onde a tabela ser\u00e1 criada ou atualizada. O valor padr\u00e3o \u00e9 <code>'db.duckdb'</code>.</p> <code>'db.duckdb'</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se a fun\u00e7\u00e3o for chamada com um cursor incompat\u00edvel.</p> Exemplo <pre><code>from athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(...)\n\nwith Athena(cursor) as athena:\n    athena.to_insert_table_db(\n        table_name=\"tabela_destino\",\n        database=\"meu_banco.duckdb\"\n    )\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_pandas","title":"<code>to_pandas(*args, **kwargs)</code>","text":"<p>Exporta os resultados de uma consulta para um DataFrame pandas.</p> <p>Este m\u00e9todo converte os resultados da consulta executada em diferentes tipos de cursor para um DataFrame pandas. Ele suporta cursors do tipo <code>CursorParquetDuckdb</code>, <code>CursorPython</code> e <code>CursorParquet</code>, adaptando-se conforme o tipo de cursor utilizado.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Argumentos adicionais que ser\u00e3o passados para o m\u00e9todo <code>to_pandas</code> do cursor.</p> <code>()</code> <code>**kwargs</code> <p>Argumentos adicionais que ser\u00e3o passados para o m\u00e9todo <code>to_pandas</code> do cursor.</p> <code>{}</code> Retorno <p>pd.DataFrame: Um DataFrame pandas contendo os resultados da consulta executada.</p> Exce\u00e7\u00f5es <p>ProgrammingError: Se o cursor n\u00e3o for do tipo compat\u00edvel (nenhum dos tipos mencionados acima).</p> Detalhes <ul> <li>Se o cursor for do tipo <code>CursorParquetDuckdb</code>, o m\u00e9todo utilizar\u00e1 o m\u00e9todo <code>to_pandas</code> do cursor para exportar os resultados da consulta.</li> <li>Se o cursor for do tipo <code>CursorPython</code>, os resultados da consulta ser\u00e3o obtidos via <code>fetchall()</code> e ent\u00e3o convertidos para um DataFrame pandas com os nomes das colunas extra\u00eddos da descri\u00e7\u00e3o da consulta.</li> <li>Se o cursor for do tipo <code>CursorParquet</code>, os resultados ser\u00e3o convertidos para o formato Arrow e, em seguida, para um DataFrame pandas utilizando o m\u00e9todo apropriado.</li> </ul> Exemplo <pre><code>from athena_mvsh import Athena, CursorPython\n\ncursor = CursorPython(...)\n\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    df = athena.to_pandas()\n\nprint(df.head())\n</code></pre> Notas <ul> <li>A fun\u00e7\u00e3o \u00e9 adapt\u00e1vel para diferentes tipos de cursor e utiliza os m\u00e9todos espec\u00edficos de cada um para converter os resultados para um DataFrame pandas.</li> <li>A compatibilidade do cursor \u00e9 verificada antes de tentar acessar o m\u00e9todo <code>to_pandas</code> espec\u00edfico de cada tipo de cursor.</li> <li>A funcionalidade depende de cada tipo de cursor implementado (como <code>CursorParquetDuckdb</code>, <code>CursorPython</code> e <code>CursorParquet</code>).</li> </ul>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_parquet","title":"<code>to_parquet(*args, **kwargs)</code>","text":"<p>Converte os resultados da consulta para o formato Parquet.</p> <p>Este m\u00e9todo converte os dados retornados pela consulta executada em um arquivo Parquet. A convers\u00e3o \u00e9 realizada apenas se o cursor utilizado for do tipo <code>CursorParquet</code> ou <code>CursorParquetDuckdb</code>. Dependendo do tipo do cursor, o m\u00e9todo chama a fun\u00e7\u00e3o <code>to_parquet</code> correspondente.</p> <ul> <li> <p>Se o cursor for uma inst\u00e2ncia de <code>CursorParquetDuckdb</code>, o m\u00e9todo chamar\u00e1 diretamente o m\u00e9todo <code>to_parquet</code> do cursor, passando os argumentos fornecidos para ele.</p> </li> <li> <p>Para o cursor <code>CursorParquet</code>, os dados s\u00e3o primeiro convertidos para um <code>pa.Table</code> e ent\u00e3o s\u00e3o gravados como Parquet.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Argumentos adicionais passados para a fun\u00e7\u00e3o <code>to_parquet</code> do cursor. - Para detalhes sobre os argumentos esperados, consulte a documenta\u00e7\u00e3o do <code>DuckDB</code> e <code>PyArrow</code>:     - DuckDB: https://duckdb.org/docs     - PyArrow: https://arrow.apache.org/docs/python/</p> <code>()</code> <code>**kwargs</code> <p>Argumentos de palavra-chave adicionais passados para a fun\u00e7\u00e3o</p> <code>{}</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se o cursor n\u00e3o for uma inst\u00e2ncia de <code>CursorParquet</code> ou <code>CursorParquetDuckdb</code>.</p> Retorno <p>None: Este m\u00e9todo n\u00e3o retorna valor, mas realiza a convers\u00e3o para o formato Parquet.</p> Exemplo <pre><code>cursor = CursorParquet(...)\nwith Athena(cursor) as athena:\n    athena.execute(\"SELECT id, name FROM users\")\n    athena.to_parquet('/path/to/file.parquet')\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.to_partition_create_table_db","title":"<code>to_partition_create_table_db(table_name, *, database='db.duckdb', workers=WORKERS)</code>","text":"<p>L\u00ea arquivos Parquet gerados a partir da consulta executada e insere os dados na tabela do banco de dados DuckDB.</p> <p>Este m\u00e9todo executa uma consulta no Athena para gerar arquivos Parquet que s\u00e3o armazenados no S3. Ap\u00f3s a consulta, os arquivos Parquet s\u00e3o lidos e os dados s\u00e3o inseridos na tabela especificada no DuckDB. A inser\u00e7\u00e3o dos dados \u00e9 paralelizada utilizando m\u00faltiplos trabalhadores (threads) para otimizar o desempenho.</p> <p>O m\u00e9todo realiza os seguintes passos: - Executa a consulta fornecida no Athena para gerar os arquivos Parquet. - Descarrega os arquivos Parquet do S3 a partir do manifest gerado pela consulta. - Para cada arquivo Parquet, insere os dados na tabela especificada no DuckDB, utilizando <code>ThreadPoolExecutor</code> para paralelizar as inser\u00e7\u00f5es.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>O nome da tabela onde os dados ser\u00e3o inseridos no DuckDB.</p> required <code>database</code> <code>(str, opcional)</code> <p>O nome do banco de dados DuckDB. O valor padr\u00e3o \u00e9 'db.duckdb'.</p> <code>'db.duckdb'</code> <code>workers</code> <code>(int, opcional)</code> <p>O n\u00famero de trabalhadores (threads) a serem usados para paralelizar a inser\u00e7\u00e3o dos arquivos Parquet. O valor padr\u00e3o \u00e9 <code>WORKERS</code>.</p> <code>WORKERS</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se o cursor n\u00e3o for do tipo <code>CursorParquetDuckdb</code>. Exception: Se ocorrer um erro durante a execu\u00e7\u00e3o da inser\u00e7\u00e3o dos dados.</p> Retorno <p>None: O m\u00e9todo n\u00e3o retorna valor, mas insere os dados na tabela do banco de dados DuckDB.</p> Exemplo <pre><code>cursor = CursorParquetDuckdb(...)\nwith Athena(cursor) as athena:\n    athena.to_partition_create_table_db(\n        table_name='target_table',\n        database='db.duckdb',\n        workers=4\n    )\n</code></pre>"},{"location":"referencia/#athena_mvsh.connection.Athena.write_arrow","title":"<code>write_arrow(tbl, table_name, schema, location=None, partitions=None, catalog_name='awsdatacatalog', compression='ZSTD')</code>","text":"<p>Escreve um Table Arrow em uma tabela externa no Athena usando o DuckDB.</p> <p>Este m\u00e9todo utiliza o DuckDB para escrever um Table Arrow como uma tabela externa no Amazon Athena, permitindo especificar o esquema, particionamento e compress\u00e3o dos dados. Caso o cursor utilizado n\u00e3o seja compat\u00edvel, um erro ser\u00e1 lan\u00e7ado.</p> <p>Parameters:</p> Name Type Description Default <code>tbl</code> <code>Table</code> <p>O Table Arrow que ser\u00e1 escrito na tabela externa no Athena.</p> required <code>table_name</code> <code>str</code> <p>O nome da tabela externa de destino no Athena.</p> required <code>schema</code> <code>str</code> <p>O esquema onde a tabela ser\u00e1 criada ou atualizada no Athena.</p> required <code>location</code> <code>str</code> <p>O local onde os dados ser\u00e3o armazenados (geralmente um bucket S3), se aplic\u00e1vel.</p> <code>None</code> <code>partitions</code> <code>list[str]</code> <p>Lista de colunas para particionamento dos dados na tabela.</p> <code>None</code> <code>catalog_name</code> <code>str</code> <p>O nome do cat\u00e1logo de dados a ser utilizado. O valor padr\u00e3o \u00e9 <code>'awsdatacatalog'</code>.</p> <code>'awsdatacatalog'</code> <code>compression</code> <code>Literal['ZSTD', 'SNAPPY', 'GZIP']</code> <p>O algoritmo de compress\u00e3o a ser utilizado nos dados. O valor padr\u00e3o \u00e9 <code>'ZSTD'</code>.</p> <code>'ZSTD'</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se a fun\u00e7\u00e3o for chamada com um cursor incompat\u00edvel.</p> Detalhes <ul> <li>O Table Arrow fornecido ser\u00e1 convertido e escrito como uma tabela externa no Athena.</li> <li>A op\u00e7\u00e3o de particionamento permite distribuir os dados em v\u00e1rias pastas ou arquivos, facilitando o gerenciamento de grandes volumes de dados no S3.</li> <li>A compress\u00e3o <code>ZSTD</code> pode ser usada para reduzir o tamanho do arquivo gerado, com outras op\u00e7\u00f5es como <code>SNAPPY</code> tamb\u00e9m sendo suportadas.</li> <li>O cat\u00e1logo de dados <code>awsdatacatalog</code> pode ser alterado para refletir configura\u00e7\u00f5es espec\u00edficas do ambiente de execu\u00e7\u00e3o.</li> </ul> Exemplo <pre><code>import pandas as pd\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(...)\n\n# Exemplo de DataFrame\ndf = pd.DataFrame({\n    \"coluna1\": [1, 2, 3],\n    \"coluna2\": [\"A\", \"B\", \"C\"]\n})\n\n# Escreve o Table Arrow em uma tabela externa no Athena\nwith Athena(cursor) as athena:\n    athena.write_arrow(\n        tbl,\n        table_name=\"tabela_destino\",\n        schema=\"meu_esquema\",\n        location=\"s3://meu-bucket/dados/\",\n        partitions=[\"coluna1\"],\n        catalog_name=\"meu_catalogo\",\n        compression=\"ZSTD\"\n    )\n</code></pre> Notas <ul> <li>Certifique-se de que o cursor utilizado seja inst\u00e2ncia de <code>CursorParquetDuckdb</code>.</li> <li>O particionamento \u00e9 \u00fatil para grandes volumes de dados, permitindo consultas mais eficientes no Athena.</li> <li>A compress\u00e3o pode ser ajustada para balancear entre desempenho e tamanho do arquivo.</li> </ul>"},{"location":"referencia/#athena_mvsh.connection.Athena.write_dataframe","title":"<code>write_dataframe(df, table_name, schema, location=None, partitions=None, catalog_name='awsdatacatalog', compression='ZSTD')</code>","text":"<p>Escreve um DataFrame pandas em uma tabela externa no Athena usando o DuckDB.</p> <p>Este m\u00e9todo utiliza o DuckDB para escrever um DataFrame pandas como uma tabela externa no Amazon Athena, permitindo especificar o esquema, particionamento e compress\u00e3o dos dados. Caso o cursor utilizado n\u00e3o seja compat\u00edvel, um erro ser\u00e1 lan\u00e7ado.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>O DataFrame pandas que ser\u00e1 escrito na tabela externa no Athena.</p> required <code>table_name</code> <code>str</code> <p>O nome da tabela externa de destino no Athena.</p> required <code>schema</code> <code>str</code> <p>O esquema onde a tabela ser\u00e1 criada ou atualizada no Athena.</p> required <code>location</code> <code>str</code> <p>O local onde os dados ser\u00e3o armazenados (geralmente um bucket S3), se aplic\u00e1vel.</p> <code>None</code> <code>partitions</code> <code>list[str]</code> <p>Lista de colunas para particionamento dos dados na tabela.</p> <code>None</code> <code>catalog_name</code> <code>str</code> <p>O nome do cat\u00e1logo de dados a ser utilizado. O valor padr\u00e3o \u00e9 <code>'awsdatacatalog'</code>.</p> <code>'awsdatacatalog'</code> <code>compression</code> <code>Literal['ZSTD', 'SNAPPY', 'GZIP']</code> <p>O algoritmo de compress\u00e3o a ser utilizado nos dados. O valor padr\u00e3o \u00e9 <code>'ZSTD'</code>.</p> <code>'ZSTD'</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se a fun\u00e7\u00e3o for chamada com um cursor incompat\u00edvel.</p> Detalhes <ul> <li>O DataFrame pandas fornecido ser\u00e1 convertido e escrito como uma tabela externa no Athena.</li> <li>A op\u00e7\u00e3o de particionamento permite distribuir os dados em v\u00e1rias pastas ou arquivos, facilitando o gerenciamento de grandes volumes de dados no S3.</li> <li>A compress\u00e3o <code>ZSTD</code> pode ser usada para reduzir o tamanho do arquivo gerado, com outras op\u00e7\u00f5es como <code>SNAPPY</code> tamb\u00e9m sendo suportadas.</li> <li>O cat\u00e1logo de dados <code>awsdatacatalog</code> pode ser alterado para refletir configura\u00e7\u00f5es espec\u00edficas do ambiente de execu\u00e7\u00e3o.</li> </ul> Exemplo <pre><code>import pandas as pd\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(...)\n\n# Exemplo de DataFrame\ndf = pd.DataFrame({\n    \"coluna1\": [1, 2, 3],\n    \"coluna2\": [\"A\", \"B\", \"C\"]\n})\n\n# Escreve o DataFrame em uma tabela externa no Athena\nwith Athena(cursor) as athena:\n    athena.write_dataframe(\n        df,\n        table_name=\"tabela_destino\",\n        schema=\"meu_esquema\",\n        location=\"s3://meu-bucket/dados/\",\n        partitions=[\"coluna1\"],\n        catalog_name=\"meu_catalogo\",\n        compression=\"ZSTD\"\n    )\n</code></pre> Notas <ul> <li>Certifique-se de que o cursor utilizado seja inst\u00e2ncia de <code>CursorParquetDuckdb</code>.</li> <li>O particionamento \u00e9 \u00fatil para grandes volumes de dados, permitindo consultas mais eficientes no Athena.</li> <li>A compress\u00e3o pode ser ajustada para balancear entre desempenho e tamanho do arquivo.</li> </ul>"},{"location":"referencia/#athena_mvsh.connection.Athena.write_parquet","title":"<code>write_parquet(file, table_name, schema, location=None, partitions=None, catalog_name='awsdatacatalog', compression='ZSTD')</code>","text":"<p>Cria uma tabela externa no Athena a partir de um ou v\u00e1rios arquivos Parquet.</p> <p>Este m\u00e9todo utiliza o DuckDB para criar uma tabela externa no Amazon Athena a partir de arquivos Parquet, permitindo especificar o esquema, particionamento e compress\u00e3o dos dados. Caso o cursor utilizado n\u00e3o seja compat\u00edvel, um erro ser\u00e1 lan\u00e7ado.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>list[str | Path] | str | Path</code> <p>Um ou v\u00e1rios caminhos para arquivos Parquet ou diret\u00f3rios contendo arquivos Parquet. Pode ser uma lista ou uma \u00fanica string/Path.</p> required <code>table_name</code> <code>str</code> <p>O nome da tabela externa a ser criada no Athena.</p> required <code>schema</code> <code>str</code> <p>O esquema onde a tabela ser\u00e1 criada ou atualizada no Athena.</p> required <code>location</code> <code>str</code> <p>O local no S3 onde os arquivos Parquet ser\u00e3o armazenados, se aplic\u00e1vel.</p> <code>None</code> <code>partitions</code> <code>list[str]</code> <p>Lista de colunas para particionamento dos dados na tabela.</p> <code>None</code> <code>catalog_name</code> <code>str</code> <p>O nome do cat\u00e1logo de dados a ser utilizado. O valor padr\u00e3o \u00e9 <code>'awsdatacatalog'</code>.</p> <code>'awsdatacatalog'</code> <code>compression</code> <code>Literal['ZSTD', 'SNAPPY', 'GZIP']</code> <p>O algoritmo de compress\u00e3o a ser utilizado nos dados. O valor padr\u00e3o \u00e9 <code>'ZSTD'</code>.</p> <code>'ZSTD'</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se a fun\u00e7\u00e3o for chamada com um cursor incompat\u00edvel.</p> Detalhes <ul> <li>O(s) arquivo(s) Parquet fornecido(s) ser\u00e3o usados para criar uma tabela externa no Athena.</li> <li>A op\u00e7\u00e3o de particionamento permite distribuir os dados em v\u00e1rias pastas ou arquivos no S3, facilitando o gerenciamento de grandes volumes de dados.</li> <li>A compress\u00e3o <code>ZSTD</code> pode ser usada para reduzir o tamanho dos arquivos Parquet gerados, com outras op\u00e7\u00f5es como <code>SNAPPY</code> tamb\u00e9m sendo suportadas.</li> <li>O cat\u00e1logo de dados <code>awsdatacatalog</code> pode ser alterado para refletir configura\u00e7\u00f5es espec\u00edficas do ambiente de execu\u00e7\u00e3o.</li> </ul> Exemplo <pre><code>from pathlib import Path\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(...)\n\n# Caminho para os arquivos Parquet\narquivos_parquet = Path(\"/caminho/para/arquivos/*.parquet\")\n\n# Cria uma tabela externa no Athena a partir dos arquivos Parquet\nwith Athena(cursor) as athena:\n    athena.write_parquet(\n        file=arquivos_parquet,\n        table_name=\"tabela_destino\",\n        schema=\"meu_esquema\",\n        location=\"s3://meu-bucket/dados/\",\n        partitions=[\"coluna1\"],\n        catalog_name=\"meu_catalogo\"\n    )\n</code></pre> Notas <ul> <li>Certifique-se de que o cursor utilizado seja inst\u00e2ncia de <code>CursorParquetDuckdb</code>.</li> <li>O particionamento \u00e9 \u00fatil para grandes volumes de dados, permitindo consultas mais eficientes no Athena.</li> <li>A compress\u00e3o pode ser ajustada para balancear entre desempenho e tamanho do arquivo.</li> </ul>"},{"location":"referencia/#athena_mvsh.connection.Athena.write_table_iceberg","title":"<code>write_table_iceberg(data, table_name, schema, location=None, partitions=None, catalog_name='awsdatacatalog', compression='ZSTD', if_exists='replace', sync_schema=False)</code>","text":"<p>Cria ou insere dados em uma tabela Iceberg no Athena a partir de um DataFrame pandas, Table Arrow ou arquivos Parquet.</p> <p>Este m\u00e9todo usa o DuckDB para criar ou inserir dados em uma tabela Iceberg no Amazon Athena, permitindo que os dados sejam inseridos a partir de um DataFrame pandas, Table Arrow ou m\u00faltiplos arquivos Parquet. A opera\u00e7\u00e3o pode substituir a tabela existente ou adicionar novos dados, dependendo do valor de <code>if_exists</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame | list[str | Path] | str | Path | Table</code> <p>Dados a serem inseridos ou criados na tabela Iceberg. Pode ser um DataFrame pandas, Table Arrow ou um ou mais arquivos Parquet (caminhos em formato string ou Path).</p> required <code>table_name</code> <code>str</code> <p>O nome da tabela Iceberg a ser criada ou inserida no Athena.</p> required <code>schema</code> <code>str</code> <p>O esquema onde a tabela Iceberg ser\u00e1 criada ou atualizada no Athena.</p> required <code>location</code> <code>str</code> <p>O local no S3 onde os dados ser\u00e3o armazenados, se aplic\u00e1vel.</p> <code>None</code> <code>partitions</code> <code>list[str]</code> <p>Lista de colunas para particionamento dos dados na tabela.</p> <code>None</code> <code>catalog_name</code> <code>str</code> <p>O nome do cat\u00e1logo de dados a ser utilizado. O valor padr\u00e3o \u00e9 <code>'awsdatacatalog'</code>.</p> <code>'awsdatacatalog'</code> <code>compression</code> <code>Literal['ZSTD', 'SNAPPY', 'GZIP']</code> <p>O algoritmo de compress\u00e3o a ser utilizado nos dados. O valor padr\u00e3o \u00e9 <code>'ZSTD'</code>.</p> <code>'ZSTD'</code> <code>if_exists</code> <code>Literal['replace', 'append']</code> <p>Define se os dados devem substituir a tabela existente (<code>'replace'</code>) ou ser adicionados (<code>'append'</code>). O valor padr\u00e3o \u00e9 <code>'replace'</code>.</p> <code>'replace'</code> <code>sync_schema</code> <code>bool</code> <p>Indica se o esquema da tabela de destino deve ser sincronizado com os dados de origem. O valor padr\u00e3o \u00e9 <code>False</code>.</p> <code>False</code> Exce\u00e7\u00f5es <p>ProgrammingError: Se a fun\u00e7\u00e3o for chamada com um cursor incompat\u00edvel.</p> Detalhes <ul> <li>A tabela Iceberg ser\u00e1 criada ou atualizada no Athena com os dados fornecidos.</li> <li>O particionamento permite distribuir os dados em v\u00e1rias pastas ou arquivos no S3, facilitando o gerenciamento de grandes volumes de dados.</li> <li>A compress\u00e3o <code>ZSTD</code> pode ser usada para reduzir o tamanho dos arquivos Parquet gerados, com outras op\u00e7\u00f5es como <code>GZIP</code> tamb\u00e9m sendo suportadas.</li> <li>O cat\u00e1logo de dados <code>awsdatacatalog</code> pode ser alterado para refletir configura\u00e7\u00f5es espec\u00edficas do ambiente de execu\u00e7\u00e3o.</li> <li>O par\u00e2metro <code>if_exists</code> controla se os dados devem substituir ou ser adicionados \u00e0 tabela existente.</li> </ul> Exemplo <pre><code>import pandas as pd\nfrom athena_mvsh import Athena, CursorParquetDuckdb\n\ncursor = CursorParquetDuckdb(...)\n\n# Exemplo de DataFrame\ndf = pd.DataFrame({\n    \"coluna1\": [1, 2, 3],\n    \"coluna2\": [\"A\", \"B\", \"C\"]\n})\n\n# Cria ou insere dados na tabela Iceberg no Athena\nwith Athena(cursor) as athena:\n    athena.write_table_iceberg(\n        data=df,\n        table_name=\"tabela_iceberg\",\n        schema=\"meu_esquema\",\n        location=\"s3://meu-bucket/dados/\",\n        partitions=[\"coluna1\"],\n        catalog_name=\"meu_catalogo\",\n        if_exists=\"append\"\n    )\n</code></pre> Notas <ul> <li>Certifique-se de que o cursor utilizado seja inst\u00e2ncia de <code>CursorParquetDuckdb</code>.</li> <li>O particionamento \u00e9 \u00fatil para grandes volumes de dados, permitindo consultas mais eficientes no Athena.</li> <li>A compress\u00e3o pode ser ajustada para balancear entre desempenho e tamanho do arquivo.</li> <li>O par\u00e2metro <code>if_exists</code> permite escolher entre substituir ou adicionar dados \u00e0 tabela existente, controlando o comportamento da opera\u00e7\u00e3o.</li> </ul>"}]}